#include <math.h>
#include <stdio.h>
#include <stdint.h>

#define smooth_kernel_size 3

//#define sigma 0.707
#define sigma 1.414
//#define K 50

#define image_size 3


float fp32_to_bf16(float x){
    float y = x;
    int *p = (int *) &y;
    printf("%d", *p);
    unsigned int exp = *p & 0x7F800000;
    unsigned int man = *p & 0x007FFFFF;
    //printf("%x ", exp);
    //printf("%x ", man);

    if (exp == 0 && man == 0) /* zero */
        return x;
    if (exp == 0x7F800000) /* infinity or NaN */
        return x;

    /* Normalized number */
    /* round to nearest */
    float r = x;
    int *pr = (int *) &r;
    *pr &= 0xFF800000;  /* r has the same exp as x */
    r /= 0x100;
    y = x + r;

    *p &= 0xFFFF0000;

    return *p;
}


uint64_t mask_lowest_zero(uint64_t x)
{
    uint64_t mask = x;
    mask &= (mask << 1) | 0x1;
    mask &= (mask << 2) | 0x3;
    mask &= (mask << 4) | 0xF;
    mask &= (mask << 8) | 0xFF;
    mask &= (mask << 16) | 0xFFFF;
    mask &= (mask << 32) | 0xFFFFFFFF;
    return mask;
}
int64_t inc(int64_t x)
{
    if (~x == 0)
        return 0;
    /* TODO: Carry flag */
    int64_t mask = mask_lowest_zero(x);
    int64_t z1 = mask ^ ((mask << 1) | 1);
    return (x & ~mask) | z1;
}
static inline int64_t getbit(int64_t value, int n)
{
    return (value >> n) & 1;
}
/* int32 multiply */
int64_t imul32(int32_t a, int32_t b)
{
    int64_t r = 0, a64 = (int64_t) a, b64 = (int64_t) b;
    for (int i = 0; i < 32; i++) {
        if (getbit(b64, i))
            r += a64 << i;
    }
    return r;
}
/* float32 multiply */
float fmul32(float a, float b)
{
    /* TODO: Special values like NaN and INF */
    int32_t ia = *(int32_t *) &a, ib = *(int32_t *) &b;

    /* sign */
    int sa = ia >> 31;
    int sb = ib >> 31;

    /* mantissa */
    int32_t ma = (ia & 0x7FFFFF) | 0x800000;
    int32_t mb = (ib & 0x7FFFFF) | 0x800000;

    /* exponent */
    int32_t ea = ((ia >> 23) & 0xFF);
    int32_t eb = ((ib >> 23) & 0xFF);

    /* 'r' = result */
    int64_t mrtmp = imul32(ma, mb) >> 23;
    int mshift = getbit(mrtmp, 24);

    int64_t mr = mrtmp >> mshift;
    int32_t ertmp = ea + eb - 127;
    int32_t er = mshift ? inc(ertmp) : ertmp;
    /* TODO: Overflow ^ */
    int sr = sa ^ sb;
    int32_t r = (sr << 31) | ((er & 0xFF) << 23) | (mr & 0x7FFFFF);
    return *(float *) &r;
}

//####################################################################

int main() {
    float gauss[smooth_kernel_size][smooth_kernel_size];
    float gauss2[smooth_kernel_size][smooth_kernel_size];


    float img[image_size][image_size]={
        {30, 65, 138},
        {53,230, 240},
        {59, 87, 14}
    };
    /*
    float img[image_size][image_size]={
        {30, 65, 138, 26},
        {53,230, 240, 245},
        {59, 87, 14, 99},
        {112, 10, 90, 196}
    };
    */

    float img2[image_size][image_size] = {};
    //float img2[image_size+2][image_size+2] = {};

    float img3[image_size][image_size] = {};

    float sum = 0;
    int i, j;

    for (i = 0; i < smooth_kernel_size; i++) {
        for (j = 0; j < smooth_kernel_size; j++) {
            float x = i - (smooth_kernel_size - 1) / 2.0;
            float y = j - (smooth_kernel_size - 1) / 2.0;
            gauss[i][j] = 0.16*(1/sigma) * exp(((pow(x, 2) + pow(y, 2)) / ((2 * pow(sigma, 2)))) * (-1));
            sum += gauss[i][j];
        }
    }

    printf("The Filter Generated by Testcase\n ");
    for (i = 0; i < smooth_kernel_size; i++) {
        for (j = 0; j < smooth_kernel_size; j++) {
            gauss[i][j] /= sum;
            printf("%f ", gauss[i][j]);
        }
         printf("\n");
    }

    printf("\nThe Filter FP32\n");
    for (i = 0; i < smooth_kernel_size; i++) {
        for (j = 0; j < smooth_kernel_size; j++) {
            printf("%a ", gauss[i][j]);
            printf("\t");
        }
        printf("\n");
    }

    printf("\nThe Filter BF16\n");
    for (i = 0; i < smooth_kernel_size; i++) {
        for (j = 0; j < smooth_kernel_size; j++) {
            gauss2[i][j] = fp32_to_bf16(gauss[i][j]);
            printf(" %a ", gauss2[i][j]);
            printf("\t");
        }
        printf("\n");
    }

//////////////////////////////////////////////////////////

    printf("\nThe Image convert to BF16\n");
    for (i = 0; i < image_size; i++) {
        for (j = 0; j < image_size; j++) {
            printf("%a ", img[i][j]);
            printf("\t");

            img2[i][j] = fp32_to_bf16(img[i][j]);
            //img2[i+1][j+1] = fp32_to_bf16(img[i][j]);
        }
        printf("\n");

    }

/*
    for (i = 0; i < image_size+2; i++) {
        for (j = 0; j < image_size+2; j++) {

            printf("%a ", img2[i][j]);
            printf("\t");
        }
        printf("\n");
    }
*/

    for (i = 0; i < image_size; i++) {
        for (j = 0; j < image_size; j++) {

            printf("%a ", img2[i][j]);
            printf("\t");
        }
        printf("\n");
    }

    printf("\n");

   for(i=0; i<3; i++){
        img3[i][0] = fmul32(img2[i][0],gauss2[i][0]);
        img3[i][1] = fmul32(img2[i][1],gauss2[i][1]);
        img3[i][2] = fmul32(img2[i][2],gauss2[i][2]);
   }

   for (i = 0; i < image_size; i++) {
    for (j = 0; j < image_size; j++) {

        printf("%a ", img3[i][j]);
        printf("\t");

    }
    printf("\n");
    }


    return 0;
}



